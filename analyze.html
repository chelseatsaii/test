<!doctype html>
<html lang="zh-TW">

<head>
  <meta charset="utf-8" />
  <meta name="robots" content="noindex, nofollow">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>åˆ†æ</title>
  <link rel="stylesheet" href="css/app.css" />
  <style>
    #cameraBox {
      width: 360px;
      height: 480px;
      border-radius: 22px;
      overflow: hidden;
      position: relative;
      background: rgba(0, 0, 0, .25);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(0, 0, 0, .08);
      box-shadow: 0 20px 70px rgba(0, 0, 0, .18);
    }

    /* video + canvas cover ç–Šæ»¿ */
    #video,
    #meshCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* video + canvas cover ç–Šæ»¿ */
    /* #video, #meshCanvas{
      object-fit: contain;
    } */

    /* é¡åƒä¸€è‡´ */
    #video {
      transform: scaleX(-1);
    }

    #meshCanvas {
      transform: scaleX(-1);
      pointer-events: none;
      z-index: 2;
    }

    .hint {
      position: absolute;
      top: 14px;
      left: 12px;
      right: 12px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0, 0, 0, .26);
      border: 1px solid rgba(255, 255, 255, .22);
      color: rgba(255, 255, 255, .92);
      font-size: 13px;
      letter-spacing: .6px;
      text-align: center;
      z-index: 4;
    }

    #faceGuide {
      position: absolute;
      inset: 74px 44px 98px 44px;
      border-radius: 999px;
      border: 2px dashed rgba(255, 255, 255, .65);
      pointer-events: none;
      animation: pulse 2.5s infinite ease-in-out;
      z-index: 3;
    }

    @keyframes pulse {
      0% {
        opacity: .35;
        transform: scale(.985)
      }

      50% {
        opacity: .85;
        transform: scale(1)
      }

      100% {
        opacity: .35;
        transform: scale(.985)
      }
    }

    #captureBtn {
      position: absolute;
      left: 50%;
      bottom: 20px;
      transform: translateX(-50%);
      width: 90px;
      height: 90px;
      border-radius: 999px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255, 255, 255, .75), rgba(255, 255, 255, 0) 45%),
        linear-gradient(135deg, rgba(255, 157, 184, .95), rgba(242, 216, 140, .92));
      border: 6px solid rgba(255, 255, 255, .95);
      box-shadow: 0 10px 24px rgba(255, 157, 184, .3), 0 20px 50px rgba(0, 0, 0, .25);
      cursor: pointer;
      z-index: 5;
      opacity: 0.3;
      /* ğŸ¨ æ”¹å–„ï¼š0.4 â†’ 0.3 æ›´æ˜é¡¯çš„ç¦ç”¨ç‹€æ…‹ */
      pointer-events: none;
      filter: grayscale(0.6);
      /* ğŸ¨ æ–°å¢ï¼šç°éšæ•ˆæœå¼·åŒ–ç¦ç”¨è¦–è¦º */
      transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    #captureBtn.active {
      opacity: 1;
      pointer-events: auto;
      filter: grayscale(0);
      /* ğŸ¨ æ–°å¢ï¼šç§»é™¤ç°éšæ•ˆæœ */
      animation: capturePulse 2s infinite ease-in-out;
      box-shadow:
        0 10px 24px rgba(255, 157, 184, .4),
        0 20px 50px rgba(0, 0, 0, .3),
        0 0 0 4px rgba(255, 255, 255, .5);
      /* ğŸ¨ æ–°å¢ï¼šå¤–å…‰åœˆæ•ˆæœ */
    }

    @keyframes capturePulse {

      0%,
      100% {
        transform: translateX(-50%) scale(1);
        box-shadow: 0 10px 24px rgba(255, 157, 184, .3), 0 20px 50px rgba(0, 0, 0, .25);
      }

      50% {
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 12px 28px rgba(255, 157, 184, .4), 0 24px 60px rgba(0, 0, 0, .3);
      }
    }

    /* å¤šå±¤ç´šå°é½Šç‹€æ…‹ - æä¾›æ›´ç´°ç·»çš„è¦–è¦ºå›é¥‹ */
    #faceGuide.aligned-perfect {
      border: 3px solid #10b981;
      animation: none;
      background: rgba(16, 185, 129, 0.15);
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.3);
    }

    #faceGuide.aligned-good {
      border: 3px solid #4ade80;
      animation: none;
      background: rgba(74, 222, 128, 0.1);
    }

    #faceGuide.aligned-poor {
      border: 2px dashed rgba(255, 255, 255, .65);
      animation: pulse 2.5s infinite ease-in-out;
    }


    #cameraBox.loading::after {
      content: "AI åˆ†æä¸­â€¦";
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(10, 14, 24, .62);
      font-size: 18px;
      letter-spacing: 2px;
      z-index: 10;
    }

    /* è¼‰å…¥é€²åº¦æ¢ */
    #loadingProgress {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      max-width: 300px;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      overflow: hidden;
      z-index: 6;
      opacity: 0;
      transition: opacity 0.3s;
    }

    #loadingProgress.show {
      opacity: 1;
    }

    #loadingProgress::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: var(--progress, 0%);
      background: linear-gradient(90deg, #4ade80, #10b981);
      transition: width 0.3s ease;
    }


    #flash {
      position: fixed;
      inset: 0;
      background: #fff;
      opacity: 0;
      pointer-events: none;
      transition: opacity .15s;
      z-index: 999;
    }

    @media (max-width: 920px) {
      #cameraBox {
        width: min(92vw, 420px);
        height: min(128vw, 560px);
      }
    }

    /* ========== ç…§ç‰‡é è¦½åŠŸèƒ½ ========== */
    #previewContainer {
      position: absolute;
      inset: 0;
      background: #000;
      z-index: 20;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
    }

    #previewContainer.show {
      display: flex;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    #previewImg {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      /* ä¿æŒèˆ‡é è¦½é¡åƒä¸€è‡´ */
    }

    /* å“è³ªè©•åˆ†é¢æ¿ */
    #qualityPanel {
      position: absolute;
      bottom: 100px;
      left: 14px;
      right: 14px;
      padding: 18px;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: white;
      z-index: 21;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .quality-title {
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
      opacity: 0.95;
    }

    .quality-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .quality-row:last-child {
      margin-bottom: 0;
    }

    .quality-label {
      font-size: 14px;
      opacity: 0.85;
    }

    .quality-stars {
      color: #fbbf24;
      font-size: 16px;
      letter-spacing: 2px;
      font-family: monospace;
    }

    /* é è¦½æŒ‰éˆ•çµ„åˆ */
    .preview-btns {
      position: absolute;
      bottom: 20px;
      left: 14px;
      right: 14px;
      display: flex;
      gap: 12px;
      z-index: 21;
    }

    .preview-btn {
      flex: 1;
      padding: 16px;
      border-radius: 16px;
      border: none;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .btn-retake {
      background: rgba(255, 255, 255, 0.15);
      color: white;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .btn-proceed {
      background: linear-gradient(135deg, #4ade80, #10b981);
      color: white;
      box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
    }

    .preview-btn:active {
      transform: scale(0.96);
      filter: brightness(0.9);
    }
  </style>
</head>

<body>
  <div class="bg-glass"></div>

  <header>
    <div class="brand">
      <div class="logo"></div>
      <div>
        <h1>ç…§ç›¸</h1>
        <p>æ‹ç…§é é¢</p>
      </div>
    </div>
  </header>

  <div class="stage">
    <div id="cameraBox">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="meshCanvas"></canvas>
      <div class="hint" id="hint">ç›¸æ©Ÿå•Ÿå‹•ä¸­â€¦</div>
      <div id="faceGuide"></div>
      <div id="captureBtn" aria-label="æ‹ç…§" role="button"></div>
      <div id="loadingProgress"></div>

      <!-- ç…§ç‰‡é è¦½å®¹å™¨ -->
      <div id="previewContainer">
        <img id="previewImg" src="" alt="æ‹æ”é è¦½">
        <div id="qualityPanel">
          <div class="quality-title">ğŸ”¬ AI å“è³ªåˆ†æ</div>
          <div class="quality-row">
            <span class="quality-label">âœ¨ ç•«é¢æ¸…æ™°åº¦</span>
            <span class="quality-stars" id="star-blur">â˜…â˜…â˜…â˜…â˜…</span>
          </div>
          <div class="quality-row">
            <span class="quality-label">ğŸ’¡ å…‰ç·šå……è¶³åº¦</span>
            <span class="quality-stars" id="star-brightness">â˜…â˜…â˜…â˜…â˜…</span>
          </div>
          <div class="quality-row">
            <span class="quality-label">ğŸ“ è‡‰éƒ¨å°é½Šåº¦</span>
            <span class="quality-stars" id="star-alignment">â˜…â˜…â˜…â˜…â˜…</span>
          </div>
        </div>
        <div class="preview-btns">
          <button id="retakeBtn" class="preview-btn btn-retake">é‡æ‹</button>
          <button id="usePhotoBtn" class="preview-btn btn-proceed">ä½¿ç”¨é€™å¼µç…§ç‰‡</button>
        </div>
      </div>
    </div>
  </div>

  <div id="flash"></div>
  <div class="toast" id="toast"></div>
  <canvas id="canvas" style="display:none;"></canvas>

  <script type="module">
    import {
      FaceLandmarker,
      FilesetResolver
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";
    import { CONFIG } from "./js/config.js";

    // -------- toast ----------
    const toastEl = document.getElementById("toast");
    function toast(msg) {
      if (!toastEl) return alert(msg);
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(() => toastEl.classList.remove("show"), 2200);
    }

    // -------- DOM å¿«å–ï¼ˆå„ªåŒ–ï¼šé¿å…é‡è¤‡æŸ¥è©¢ï¼‰----------
    const DOM = {
      video: document.getElementById("video"),
      cameraBox: document.getElementById("cameraBox"),
      captureBtn: document.getElementById("captureBtn"),
      canvas: document.getElementById("canvas"),
      flash: document.getElementById("flash"),
      meshCanvas: document.getElementById("meshCanvas"),
      hint: document.getElementById("hint"),
      faceGuide: document.getElementById("faceGuide"),
      // é è¦½ç›¸é—œå…ƒç´ 
      previewContainer: document.getElementById("previewContainer"),
      previewImg: document.getElementById("previewImg"),
      retakeBtn: document.getElementById("retakeBtn"),
      usePhotoBtn: document.getElementById("usePhotoBtn"),
      starBlur: document.getElementById("star-blur"),
      starBrightness: document.getElementById("star-brightness"),
      starAlignment: document.getElementById("star-alignment")
    };

    // å‘å¾Œç›¸å®¹ï¼šä¿ç•™åŸæœ‰è®Šæ•¸åç¨±
    const video = DOM.video;
    const cameraBox = DOM.cameraBox;
    const captureBtn = DOM.captureBtn;
    const canvas = DOM.canvas;
    const flash = DOM.flash;
    const meshCanvas = DOM.meshCanvas;
    const hint = DOM.hint;

    const meshCtx = meshCanvas.getContext("2d", { alpha: true });

    // -------- data ----------
    const surveyRaw = localStorage.getItem("survey") || "{}";

    // -------- state ----------
    let stream = null;
    let busy = false;

    let faceLandmarker = null;
    let running = false;
    let lastMetrics = null;
    let isAligned = false; // æ˜¯å¦å°æº–

    // æ•ˆèƒ½å„ªåŒ–ï¼šFPS é™åˆ¶
    let lastFrameTime = 0;
    const FPS_LIMIT = 30; // é™åˆ¶åœ¨ 30 FPS ä»¥ç¯€çœé›»åŠ›
    const FRAME_INTERVAL = 1000 / FPS_LIMIT;

    // å“è³ªè©•åˆ†å¿«å–ï¼ˆç”¨æ–¼é è¦½åŠŸèƒ½ï¼‰
    let latestScores = {
      brightness: 0,
      blur: 0,
      alignment: 'poor'
    };

    const SKIP_UPLOAD = (typeof CONFIG === "object" && CONFIG !== null && "SKIP_UPLOAD" in CONFIG)
      ? CONFIG.SKIP_UPLOAD
      : true;

    // æ¡†ç·šåº§æ¨™ (å°æ‡‰ CSS inset: 74px 44px 98px 44px)
    // ç›¸æ©Ÿå¯¬åº¦ 360, é«˜åº¦ 480
    const GUIDE = {
      cx: 180, // ä¸­å¿ƒ X
      cy: 228, // ä¸­å¿ƒ Y
      w: 272,  // å¯¬åº¦
      h: 308   // é«˜åº¦
    };

    // =========================
    // cover å°é½Šï¼šcanvas å°ºå¯¸è·Ÿ cameraBox ä¸€æ¨£
    // =========================
    function syncOverlaySize() {
      const rect = cameraBox.getBoundingClientRect();
      meshCanvas.width = Math.round(rect.width * devicePixelRatio);
      meshCanvas.height = Math.round(rect.height * devicePixelRatio);
      meshCanvas.style.width = rect.width + "px";
      meshCanvas.style.height = rect.height + "px";
      meshCtx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }

    // =========================
    // åˆå§‹åŒ–æ¨¡å‹ï¼ˆå„ªåŒ–ï¼šåŠ å…¥è¼‰å…¥æç¤ºèˆ‡éŒ¯èª¤è™•ç†ï¼‰
    // =========================
    async function initModel() {
      const progressBar = document.getElementById('loadingProgress');

      try {
        // é¡¯ç¤ºé€²åº¦æ¢
        progressBar.classList.add('show');
        progressBar.style.setProperty('--progress', '10%');
        hint.textContent = "AI æ¨¡å‹è¼‰å…¥ä¸­ï¼Œè«‹ç¨å€™...";

        const fileset = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
        );
        progressBar.style.setProperty('--progress', '40%');

        faceLandmarker = await FaceLandmarker.createFromOptions(fileset, {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
            delegate: "GPU",
          },
          runningMode: "VIDEO",
          numFaces: 1,
          outputFaceBlendshapes: true,
          outputFacialTransformationMatrixes: false,
        });

        progressBar.style.setProperty('--progress', '100%');
        hint.textContent = "æ¨¡å‹è¼‰å…¥å®Œæˆï¼";

        // å»¶é²éš±è—é€²åº¦æ¢
        setTimeout(() => progressBar.classList.remove('show'), 500);
      } catch (error) {
        console.error("MediaPipe æ¨¡å‹è¼‰å…¥å¤±æ•—:", error);
        hint.textContent = "AI æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹é‡æ–°æ•´ç†é é¢";
        toast("AI æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·š");
        progressBar.classList.remove('show');
        throw error;
      }
    }

    function packMetrics(result) {
      const blend = result.faceBlendshapes?.[0]?.categories ?? [];
      return {
        ts: Date.now(),
        blendshapes: blend.map(c => ({ name: c.categoryName, score: c.score })),
      };
    }

    // =========================
    // å–å¾—è‡‰éƒ¨ç‰¹å¾µé»ï¼ˆä¸ç¹ªè£½ç¶²æ ¼ï¼Œç°¡åŒ–è¦–è¦ºï¼‰
    // =========================
    function drawEffect(result) {
      const rect = cameraBox.getBoundingClientRect();
      meshCtx.clearRect(0, 0, rect.width, rect.height);

      const landmarks = result.faceLandmarks?.[0];
      if (!landmarks || !video.videoWidth || !video.videoHeight) return [];

      const srcW = video.videoWidth;
      const srcH = video.videoHeight;
      const dstW = rect.width;
      const dstH = rect.height;
      const scale = Math.max(dstW / srcW, dstH / srcH);
      const offsetX = (dstW - srcW * scale) / 2;
      const offsetY = (dstH - srcH * scale) / 2;

      const points = new Array(landmarks.length);
      for (let i = 0; i < landmarks.length; i++) {
        const lm = landmarks[i];
        points[i] = {
          x: lm.x * srcW * scale + offsetX,
          y: lm.y * srcH * scale + offsetY
        };
      }

      // ä¸ç¹ªè£½ç¶²æ ¼ï¼Œåªå›å‚³åº§æ¨™é»ä¾›å°é½Šæª¢æ¸¬ä½¿ç”¨
      return points;
    }


    /**
     * æª¢æ¸¬ç•«é¢äº®åº¦ï¼ˆå…‰ç·šæª¢æ¸¬ï¼‰
     * @returns {number} äº®åº¦å€¼ 0-255
     */
    function detectBrightness() {
      const tempCanvas = document.createElement('canvas');
      const w = video.videoWidth;
      const h = video.videoHeight;
      if (!w || !h) return 0;

      tempCanvas.width = w;
      tempCanvas.height = h;
      const ctx = tempCanvas.getContext('2d');
      ctx.drawImage(video, 0, 0, w, h);

      const imageData = ctx.getImageData(0, 0, w, h);
      const data = imageData.data;
      let sum = 0;

      // è¨ˆç®—å¹³å‡äº®åº¦
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        // ä½¿ç”¨åŠ æ¬Šå¹³å‡è¨ˆç®—äº®åº¦
        const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
        sum += brightness;
      }

      return sum / (w * h);
    }

    /**
     * æª¢æ¸¬ç•«é¢æ¨¡ç³Šåº¦ï¼ˆä½¿ç”¨ Laplacian è®Šç•°æ•¸ï¼‰
     * @returns {number} æ¸…æ™°åº¦åˆ†æ•¸ï¼Œè¶Šé«˜è¶Šæ¸…æ™°
     */
    function detectBlur() {
      const tempCanvas = document.createElement('canvas');
      const w = Math.min(video.videoWidth, 320); // ç¸®å°ä»¥æå‡æ•ˆèƒ½
      const h = Math.min(video.videoHeight, 240);
      if (!w || !h) return 0;

      tempCanvas.width = w;
      tempCanvas.height = h;
      const ctx = tempCanvas.getContext('2d');
      ctx.drawImage(video, 0, 0, w, h);

      const imageData = ctx.getImageData(0, 0, w, h);
      const data = imageData.data;

      // ç°¡åŒ–çš„ Laplacian è¨ˆç®—
      let variance = 0;
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const idx = (y * w + x) * 4;
          const center = data[idx];
          const top = data[((y - 1) * w + x) * 4];
          const bottom = data[((y + 1) * w + x) * 4];
          const left = data[(y * w + (x - 1)) * 4];
          const right = data[(y * w + (x + 1)) * 4];

          const laplacian = Math.abs(4 * center - top - bottom - left - right);
          variance += laplacian * laplacian;
        }
      }

      return variance / (w * h);
    }

    /**
     * æª¢æŸ¥è‡‰éƒ¨å°æº–ç‹€æ…‹ï¼ˆåŠ å…¥å“è³ªæª¢æ¸¬ï¼‰
     * @param {Array<{x: number, y: number}>} points - MediaPipe åµæ¸¬åˆ°çš„è‡‰éƒ¨ç‰¹å¾µé»
     * @returns {string} å°é½Šç‹€æ…‹: 'perfect', 'good', 'poor'
     */
    function checkAlignment(points) {
      if (!points || points.length === 0) {
        updateAlignmentUI('poor');
        return 'poor';
      }


      // å–å¾—è‡‰éƒ¨ç¯„åœ
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      points.forEach(p => {
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      });

      const faceW = maxX - minX;
      const faceCx = (minX + maxX) / 2;
      const faceCy = (minY + maxY) / 2;

      const dist = Math.sqrt(Math.pow(faceCx - GUIDE.cx, 2) + Math.pow(faceCy - GUIDE.cy, 2));
      const wRatio = faceW / GUIDE.w;

      // å“è³ªæª¢æ¸¬
      const brightness = detectBrightness();
      const blurScore = detectBlur();

      // å„²å­˜å“è³ªè©•åˆ†ä¾›é è¦½ä½¿ç”¨
      latestScores.brightness = brightness;
      latestScores.blur = blurScore;
      latestScores.alignment = 'poor'; // é è¨­ç‚º poorï¼Œå¾ŒçºŒæœƒæ›´æ–°

      // å“è³ªé–¾å€¼
      const MIN_BRIGHTNESS = 80;  // æœ€ä½äº®åº¦è¦æ±‚
      const MAX_BRIGHTNESS = 220; // æœ€é«˜äº®åº¦ï¼ˆé¿å…éæ›ï¼‰
      const MIN_BLUR_SCORE = 100; // æœ€ä½æ¸…æ™°åº¦è¦æ±‚

      // åš´æ ¼çš„ä¸‰å±¤ç´šåˆ¤æ–·
      let state = 'poor';
      let qualityIssue = '';

      // æª¢æŸ¥å…‰ç·š
      if (brightness < MIN_BRIGHTNESS) {
        qualityIssue = 'å…‰ç·šä¸è¶³ï¼Œè«‹ç§»è‡³æ˜äº®è™•';
      } else if (brightness > MAX_BRIGHTNESS) {
        qualityIssue = 'å…‰ç·šéå¼·ï¼Œè«‹é¿å…å¼·å…‰';
      }
      // æª¢æŸ¥æ¸…æ™°åº¦
      else if (blurScore < MIN_BLUR_SCORE) {
        qualityIssue = 'ç•«é¢æ¨¡ç³Šï¼Œè«‹ä¿æŒç©©å®š';
      }
      // æª¢æŸ¥è·é›¢ï¼ˆæ›´åš´æ ¼ï¼‰
      else if (wRatio < 0.75 || wRatio > 1.05) {
        qualityIssue = wRatio < 0.75 ? 'è«‹é è¿‘ä¸€é»' : 'è«‹ç¨å¾®é é›¢';
      }
      // æª¢æŸ¥ä½ç½®ï¼ˆæ›´åš´æ ¼ï¼‰
      else if (dist < 20 && wRatio >= 0.9 && wRatio <= 1.0) {
        state = 'perfect'; // å®Œç¾å°æº–ï¼šè·é›¢è¿‘ã€å¤§å°å‰›å¥½ã€å…‰ç·šOKã€æ¸…æ™°
      } else if (dist < 35 && wRatio >= 0.8 && wRatio <= 1.1) {
        state = 'good'; // è‰¯å¥½å°æº–ï¼šç¨å¾®å¯¬é¬†ä¸€é»
      } else {
        qualityIssue = 'è«‹å°‡è‡‰éƒ¨ç§»è‡³æ¡†ç·šå…§';
      }

      // æ›´æ–°å°é½Šè©•åˆ†
      latestScores.alignment = state;

      updateAlignmentUI(state, qualityIssue);
      return state;
    }

    /**
     * æ›´æ–°å°é½Šç‹€æ…‹çš„ UI å›é¥‹
     */
    let currentAlignmentState = 'poor';
    function updateAlignmentUI(newState, qualityIssue = '') {
      if (newState === currentAlignmentState) return;

      // ç§»é™¤æ‰€æœ‰å°é½Šç‹€æ…‹
      DOM.faceGuide.classList.remove('aligned-perfect', 'aligned-good', 'aligned-poor');

      // åŠ å…¥æ–°ç‹€æ…‹
      DOM.faceGuide.classList.add(`aligned-${newState}`);
      currentAlignmentState = newState;

      // æ›´æ–°æŒ‰éˆ•èˆ‡æç¤ºæ–‡å­—ï¼ˆå‹å–„ç‰ˆæœ¬ï¼‰
      if (newState === 'perfect') {
        DOM.captureBtn.classList.add('active');
        DOM.hint.textContent = "âœ¨ å®Œç¾å°æº–ï¼ä¿æŒå§¿å‹¢æ‹ç…§";
      } else if (newState === 'good') {
        DOM.captureBtn.classList.add('active');
        DOM.hint.textContent = "âœ“ å·²å°æº–ï¼Œå¯ä»¥æ‹ç…§äº†";
      } else {
        DOM.captureBtn.classList.remove('active');
        // é¡¯ç¤ºå‹å–„çš„å“è³ªå•é¡Œæç¤º
        if (qualityIssue) {
          // å°‡æŠ€è¡“æ€§è¨Šæ¯è½‰æ›ç‚ºå‹å–„è¨Šæ¯
          const friendlyMessages = {
            'å…‰ç·šä¸è¶³ï¼Œè«‹ç§»è‡³æ˜äº®è™•': 'ğŸ’¡ è«‹ç§»åˆ°çª—é‚Šæˆ–é–‹ç‡ˆï¼Œè®“è‡‰éƒ¨æ›´æ˜äº®',
            'å…‰ç·šéå¼·ï¼Œè«‹é¿å…å¼·å…‰': 'â˜€ï¸ å…‰ç·šéå¼·ï¼Œè«‹é¿å…ç›´å°„å¼·å…‰',
            'ç•«é¢æ¨¡ç³Šï¼Œè«‹ä¿æŒç©©å®š': 'âœ¨ ç•«é¢æ¨¡ç³Šï¼Œè«‹æ‹¿ç©©æ‰‹æ©Ÿä¸¦ä¿æŒè‡‰éƒ¨ä¸å‹•',
            'è«‹é è¿‘ä¸€é»': 'ğŸ“ è«‹å°‡è‡‰éƒ¨ç§»è¿‘ä¸€é»ï¼Œå¡«æ»¿æ¡†ç·š',
            'è«‹ç¨å¾®é é›¢': 'ğŸ“ è«‹ç¨å¾®é é›¢ä¸€é»',
            'è«‹å°‡è‡‰éƒ¨ç§»è‡³æ¡†ç·šå…§': 'è«‹å°‡è‡‰éƒ¨ç§»è‡³æ¡†ç·šå…§'
          };
          DOM.hint.textContent = friendlyMessages[qualityIssue] || qualityIssue;
        } else {
          DOM.hint.textContent = "è«‹å°‡è‡‰éƒ¨ç§»è‡³æ¡†ç·šå…§";
        }
      }
    }


    /**
     * ä¸»åµæ¸¬è¿´åœˆï¼ˆå„ªåŒ–ï¼šåŠ å…¥ FPS é™åˆ¶ä»¥ç¯€çœæ•ˆèƒ½ï¼‰
     */
    function loop(timestamp) {
      if (!running) return;

      // æ•ˆèƒ½å„ªåŒ–ï¼šé™åˆ¶ FPS
      if (timestamp - lastFrameTime < FRAME_INTERVAL) {
        requestAnimationFrame(loop);
        return;
      }
      lastFrameTime = timestamp;

      if (!video.videoWidth || !video.videoHeight) {
        requestAnimationFrame(loop);
        return;
      }

      try {
        const now = performance.now();
        const result = faceLandmarker.detectForVideo(video, now);
        const points = drawEffect(result);
        checkAlignment(points);
        lastMetrics = packMetrics(result);
      } catch (e) {
        console.error("MediaPipe åµæ¸¬éŒ¯èª¤:", e);
        meshCtx.clearRect(0, 0, meshCanvas.width, meshCanvas.height);
        // éŒ¯èª¤è™•ç†ï¼šå¦‚æœé€£çºŒå¤±æ•—ï¼Œæç¤ºä½¿ç”¨è€…
        if (!window._detectionErrorCount) window._detectionErrorCount = 0;
        window._detectionErrorCount++;
        if (window._detectionErrorCount > 100) {
          toast("è‡‰éƒ¨åµæ¸¬ç•°å¸¸ï¼Œè«‹é‡æ–°æ•´ç†é é¢");
          window._detectionErrorCount = 0;
        }
      }

      requestAnimationFrame(loop);
    }

    // =========================
    // ç›¸æ©Ÿ
    // =========================
    /**
     * é–‹å•Ÿç›¸æ©Ÿï¼ˆå„ªåŒ–ï¼šåŠ å…¥å®Œæ•´éŒ¯èª¤è™•ç†ï¼‰
     */
    async function openCamera() {
      try {
        if (!navigator.mediaDevices?.getUserMedia) {
          throw new Error("æ­¤ç€è¦½å™¨ä¸æ”¯æ´ç›¸æ©ŸåŠŸèƒ½");
        }

        hint.textContent = "æ­£åœ¨é–‹å•Ÿç›¸æ©Ÿ...";

        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });

        video.srcObject = stream;

        await new Promise(resolve => {
          if (video.readyState >= 2) return resolve();
          video.onloadedmetadata = () => resolve();
        });

        // autoplay ä¿éšªï¼šæœ‰äº›ç’°å¢ƒæœƒå¡ä½
        const kick = async () => { try { await video.play(); } catch (e) { } };
        await kick();
        window.addEventListener("pointerdown", kick, { once: true });

        syncOverlaySize();
        window.addEventListener("resize", syncOverlaySize);

        if (!faceLandmarker) await initModel();

        running = true;
        hint.textContent = "ç›¸æ©Ÿå·²å•Ÿå‹•ï¼Œè«‹å°æº–æ¡†ç·šå¾ŒæŒ‰ä¸‹æ‹ç…§";
        loop();
      } catch (error) {
        console.error("ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—:", error);
        hint.textContent = "ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—";

        // æ ¹æ“šéŒ¯èª¤é¡å‹çµ¦äºˆä¸åŒæç¤º
        if (error.name === "NotAllowedError") {
          toast("è«‹å…è¨±ä½¿ç”¨ç›¸æ©Ÿæ¬Šé™");
        } else if (error.name === "NotFoundError") {
          toast("æ‰¾ä¸åˆ°ç›¸æ©Ÿè£ç½®");
        } else {
          toast("ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—ï¼Œè«‹ä½¿ç”¨ Chrome æˆ– Safari");
        }
        throw error;
      }
    }

    function stopCamera() {
      running = false;
      meshCtx.clearRect(0, 0, meshCanvas.width, meshCanvas.height);

      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
    }

    function flashOnce() {
      flash.style.opacity = 1;
      setTimeout(() => flash.style.opacity = 0, 120);
    }

    async function getJpegBlob() {
      const w = video.videoWidth;
      const h = video.videoHeight;
      if (!w || !h) throw new Error("Video not ready");

      canvas.width = w;
      canvas.height = h;

      const ctx = canvas.getContext("2d");
      ctx.save();
      ctx.translate(w, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(video, 0, 0, w, h);
      ctx.restore();

      const blob = await new Promise(resolve => {
        canvas.toBlob(b => resolve(b), "image/jpeg", 0.95);
      });
      if (!blob) throw new Error("toBlob failed");
      return blob;
    }

    /**
     * è¼”åŠ©å‡½æ•¸ï¼šç”Ÿæˆæ˜Ÿæ˜Ÿå­—ä¸²
     */
    function getStarString(count) {
      return "â˜…".repeat(count) + "â˜†".repeat(5 - count);
    }

    /**
     * é¡¯ç¤ºç…§ç‰‡é è¦½èˆ‡å“è³ªè©•åˆ†
     */
    function showPhotoPreview(dataUrl) {
      // åœæ­¢ç›¸æ©Ÿä»¥ç¯€çœè³‡æº
      stopCamera();

      // é¡¯ç¤ºé è¦½åœ–ç‰‡
      DOM.previewImg.src = dataUrl;

      // è¨ˆç®—æ¸…æ™°åº¦æ˜Ÿæ˜Ÿ (blur score ç¯„åœç´„ 100-500+)
      let blurStars = 2;
      if (latestScores.blur > 400) blurStars = 5;
      else if (latestScores.blur > 250) blurStars = 4;
      else if (latestScores.blur > 150) blurStars = 3;
      DOM.starBlur.textContent = getStarString(blurStars);

      // è¨ˆç®—äº®åº¦æ˜Ÿæ˜Ÿ (brightness ç¯„åœç´„ 80-220)
      let brightStars = 2;
      const b = latestScores.brightness;
      if (b >= 120 && b <= 180) brightStars = 5;
      else if (b >= 100 && b <= 200) brightStars = 4;
      else if (b >= 80 && b <= 220) brightStars = 3;
      DOM.starBrightness.textContent = getStarString(brightStars);

      // è¨ˆç®—å°é½Šæ˜Ÿæ˜Ÿ
      let alignStars = 2;
      if (latestScores.alignment === 'perfect') alignStars = 5;
      else if (latestScores.alignment === 'good') alignStars = 4;
      DOM.starAlignment.textContent = getStarString(alignStars);

      // é¡¯ç¤ºé è¦½å®¹å™¨
      DOM.previewContainer.classList.add("show");
      DOM.hint.textContent = "è«‹ç¢ºèªç…§ç‰‡å“è³ª";
    }

    // é‡æ‹æŒ‰éˆ•
    DOM.retakeBtn.onclick = () => {
      DOM.previewContainer.classList.remove("show");
      openCamera(); // é‡æ–°å•Ÿå‹•ç›¸æ©Ÿ
    };

    // ä½¿ç”¨ç…§ç‰‡æŒ‰éˆ•
    DOM.usePhotoBtn.onclick = async () => {
      if (busy) return;
      busy = true;

      cameraBox.classList.add("loading");
      DOM.hint.textContent = "æ­£åœ¨è™•ç†ç…§ç‰‡...";

      try {
        const dataUrl = localStorage.getItem("user_photo");
        if (!dataUrl) throw new Error("No photo found");

        if (SKIP_UPLOAD) {
          localStorage.removeItem("result");
          location.href = "survey_new.html?demo=1";
          return;
        }

        // å¦‚æœéœ€è¦ä¸Šå‚³åˆ°å¾Œç«¯ï¼Œä½¿ç”¨å„²å­˜çš„ blob
        const blob = window._tempBlob;
        if (!blob) throw new Error("No blob found");

        const form = new FormData();
        form.append("photo", blob, "capture.jpg");
        form.append("survey", surveyRaw);
        if (lastMetrics) form.append("metrics_json", JSON.stringify(lastMetrics));

        const res = await fetch("api/analyze.php", { method: "POST", body: form });

        if (!res.ok) {
          toast("å¾Œç«¯åˆ†æå¤±æ•—ï¼ˆè«‹çœ‹ api/analyze.phpï¼‰");
          return;
        }

        const ct = res.headers.get("content-type") || "";
        if (!ct.includes("application/json")) {
          const text = await res.text();
          console.error("Non-JSON response:", text.slice(0, 400));
          toast("å¾Œç«¯å›å‚³ä¸æ˜¯ JSONï¼ˆè«‹æª¢æŸ¥ PHP è¼¸å‡ºï¼‰");
          return;
        }

        const payload = await res.json();
        localStorage.setItem("result", JSON.stringify(payload));

        location.href = "survey_new.html";
      } catch (e) {
        console.error(e);
        toast("ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹é‡è©¦");
        busy = false;
        cameraBox.classList.remove("loading");
      }
    };

    captureBtn.addEventListener("click", async () => {
      if (busy) return;


      busy = true;
      cameraBox.classList.add("loading");

      try {
        if (!stream) throw new Error("camera not started");

        const blob = await getJpegBlob();
        flashOnce();

        const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
        localStorage.setItem("user_photo", dataUrl);

        // å„²å­˜ blob ä¾›å¾ŒçºŒä½¿ç”¨
        window._tempBlob = blob;

        // é¡¯ç¤ºé è¦½è€Œéç›´æ¥è·³è½‰
        showPhotoPreview(dataUrl);

      } catch (e) {
        console.error(e);
        toast("æ‹ç…§å¤±æ•—ï¼Œè«‹é‡è©¦");
      } finally {
        cameraBox.classList.remove("loading");
        busy = false;
      }
    });

    // é€²é é¢å°±å•Ÿå‹•ç›¸æ©Ÿï¼ˆç›´æ¥åŸ·è¡Œï¼Œä¸ç”¨ DOMContentLoadedï¼‰
    openCamera().catch(e => {
      console.error(e);
      toast("ç„¡æ³•é–‹å•Ÿç›¸æ©Ÿï¼šè«‹å…è¨±æ¬Šé™");
      hint.textContent = "ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—ï¼šè«‹å…è¨±æ¬Šé™";
    });

    window.addEventListener("beforeunload", stopCamera);
  </script>
</body>

</html>